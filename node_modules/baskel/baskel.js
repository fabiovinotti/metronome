/* Component
------------------------------------------------------------------------------*/
export class Component {
  constructor( options ) {

    this.events = {}; // { eventType: { selector: callback, ... }, ... }

    if ( typeof options !== 'object' ) {
      return;
    }

    // Base Element
    if ( options.hasOwnProperty( 'baseElement' ) ) {
      this.baseElement = document.querySelector( options.baseElement ) || undefined;
    }

    // DOM Elements
    if ( options.hasOwnProperty( 'elements' ) ) {
      for ( let element in options.elements ) {
        this.addElement( element, options.elements[element] );
      }
    }

    // Data
    if ( options.hasOwnProperty( 'data' ) ) {
      for ( let prop in options.data ) {
        this[prop] = options.data[prop];
      }
    }

    // Getters
    if ( options.hasOwnProperty( 'getters' ) ) {
      for ( let getter in options.getters ) {
        Object.defineProperty( this, getter, {
          get: options.getters[getter]
        });
      }
    }

    // Event Listeners
    if ( options.hasOwnProperty( 'eventListeners' ) ) {
      for ( let listener in options.eventListeners ) {
        const firstWhitespaceIndex = listener.search( /\s/ );
        const eventType = listener.slice( 0, firstWhitespaceIndex );
        const selector = listener.slice( firstWhitespaceIndex + 1 );

        if ( !this.events.hasOwnProperty(eventType) ) {
          this.events[eventType] = {};
        }

        this.events[eventType][selector] = options.eventListeners[listener].bind(this);
      }
      for ( let eventType in this.events ) {
        this.baseElement.addEventListener( eventType, this.handleEvent.bind(this) );
      }
    }

    // Methods
    if ( options.hasOwnProperty( 'methods' ) ) {
      Object.assign( this, options.methods );
    }

    // Init Function
    if ( options.hasOwnProperty( 'init' ) && typeof options.init === 'function' ) {
      options.init.call( this );
    }
  }

  addElement( elementName, selector ) {
    let retrievedElement;

    if ( selector[0] === '#' ) {
      retrievedElement = this.querySelector( selector );
    } else {
      retrievedElement = this.querySelectorAll( selector );
    }

    this[elementName] = retrievedElement;
  }

  handleEvent( evt ) {
    evt.stopPropagation();
    if ( evt.target === evt.currentTarget || !this.events.hasOwnProperty( evt.type ) ) {
      return;
    }

    const selectors = this.events[evt.type];
    const element = evt.target;

    for ( let selector in selectors ) {
      if ( element.matches(`${selector}, ${selector} *`) ) {
        this.events[evt.type][selector]( evt );
      }
    }
  }

  querySelector( selectors ) {
    return this.baseElement.querySelector( selectors );
  }

  querySelectorAll( selectors ) {
    return this.baseElement.querySelectorAll( selectors );
  }

}

/* Custom Events
------------------------------------------------------------------------------*/
export const CustomEvents = (function() {

  const events = {}; // {eventType: [listener, ...], ... }

  function dispatch( eventType, ...args ) {

    if ( typeof eventType !== 'string' || !events[eventType] ) {
      return;
    }

    const listeners = events[eventType];
    for ( let listener of listeners ) {
      listener( ...args );
    }

  }

  function on( eventType, listener, context = null ) {

    if ( typeof listener !== 'function' || typeof eventType !== 'string' ) {
      return;
    }

    if ( !events.hasOwnProperty( eventType ) ) {
      events[eventType] = [];
    }

    let fn;
    if ( context ) {
      fn = listener.bind( context );
    } else {
      fn = listener;
    }

    events[eventType].push( fn );

  }

  return {
    dispatch,
    on
  };

})();
